---
layout: post
title: Week 6, July 19
---

Second to the last week of Generic Programming. It's hard to imagine that we're close to the end of the 9-week summer session. Man, how time flies! It feels like we just finished week 1 and collatz! This week was another challenging assignment. It involved implementing our own deque container which emulated the standard template library deque container. The standard deque is a double ended queue where adding and removing items from the front and back is an amortized constant cost. However, inserting an item in the middle of the deque is linear cost. We were given the skeleton code for the assignment and had to implement the deque class structure as well as inner classes const_iterator and iterator (non-const version). Unfortunately, as far as the assignment goes, we made the assignment more difficult than it had to be. I realized after finishing the assignment that we put too much flexibility into our implementation, which in turn made expanding the container more difficult. We had both allocated and unallocated space for our inner arrays that we tracked, which was unnecessary and resulted in having to keep track of way too many pointers. We should have just allocated enough space to the user and once that was filled and more space was requested, only then should we have allocated more space. Now that I see the unnecessary complexity, I'm going to go back and optimize our solution. I wish I had this insight a week ago!

On another note, we had guest speakers from Atlassian this week. You know them if you use Bitbucket or Hipchat. The speakers were developers who explained their project management process. They employ a variant of agile development that eschews using hard timelines as a metric on completing smaller tasks. Instead, the developers meet and estimate the difficulty of accomplishing a particular task based on each user's familiarity and experience of implementing a possible solution to the task. It seemed like a pretty good way of making incremental progress on large projects. I'm just used to the standard old Microsoft Project way of doing things, which is a linear based timeline on completing projects. However, if you miss one goal, then every subsequent goal is pushed back and affected. By the way, this happens a lot, so I see the benefit of managing projects using an agile like process. Anyhow, that's all I got for this week! One more week of class, then the final! See you one last time.

Tip of the Week: Keep it simple stupid. I definitely did not follow this age old advice. As Professor Downing says, always implement the simplest possible solution, then go from there. Unforunately, I thought I was employing some foresight by using both allocated and unallocated space in this week's assignment, but all we did was add too much complexity. So don't make life and your projects hard on yourself! Keep it simple!
